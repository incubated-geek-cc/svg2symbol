(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.pick = factory());
}(this, (function () { 'use strict';

	var shallowProperty = key => obj => obj == null ? void 0 : obj[key];

	var getLength = shallowProperty('length');

	const MAX_ARRAY_INDEX = 2 ** 53 - 1;

	var isArrayLike = (collection) => {
		const length = getLength(collection);

		return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	};

	var isFunction = obj => toString.call(obj) === '[object Function]';

	var isObject = obj => {
		const type = typeof obj;

		return type === 'function' || type === 'object' && !!obj;
	};

	var isArguments = obj => toString.call(obj) === '[object Arguments]';

	var identity = value => value;

	var getKeys = (obj) => {
		if (!isObject(obj)) return [];

		return Object.keys(obj);
	};

	const deepGet = (obj, path) => {
		const { length } = path;

		for (let i = 0; i < length; i++) {
			if (obj == null) return void 0;
			obj = obj[path[i]];
		}

		return length ? obj : void 0;
	};

	var property = path => {
		if (!Array.isArray(path)) {
			return shallowProperty(path);
		}

		return obj => deepGet(obj, path);
	};

	var isMatch = (object, attrs) => {
		const keys = getKeys(attrs);
		const {length} = keys;

		if (object == null) return !length;
		const obj = Object(object);

		for (let i = 0; i < length; i++) {
			const key = keys[i];

			if (attrs[key] !== obj[key] || !(key in obj)) return false;
		}

		return true;
	};

	var matcher = attrs => {
		attrs = Object.assign({}, attrs);

		return obj => isMatch(obj, attrs);
	};

	var optimizeCb = (func, context, argCount) => {
		if (context === void 0) return func;
		switch (argCount == null ? 3 : argCount) {
			case 1: return value => func.call(context, value);
				// The 2-argument case is omitted because weâ€™re not using it.
			case 3: return (value, index, collection) => func.call(context, value, index, collection);
			case 4: return (accumulator, value, index, collection) => func.call(context, accumulator, value, index, collection);
		}

		return (...args) => func.apply(context, args);
	};

	const baseIteratee = (value, context, argCount) => {
		if (value == null) return identity;
		if (isFunction(value)) return optimizeCb(value, context, argCount);
		if (isObject(value) && !Array.isArray(value)) return matcher(value);

		return property(value);
	};

	let iteratee;

	const exportIteratee = iteratee = (value, context) => baseIteratee(value, context, Infinity);

	var cb = (value, context, argCount) => {
		if (iteratee !== exportIteratee) return iteratee(value, context);

		return baseIteratee(value, context, argCount);
	};

	var forEach = (obj, iteratee, context) => {
		iteratee = optimizeCb(iteratee, context);
		if (isArrayLike(obj)) {
			let i = 0;

			for (const item of obj) {
				iteratee(item, i++, obj);
			}
		} else {
			const keys = getKeys(obj);

			for (const key of keys) {
				iteratee(obj[key], key, obj);
			}
		}

		return obj;
	};

	const flatten = (input, shallow, strict, output = []) => {
		let idx = output.length;

		forEach(input, value => {
			if (isArrayLike(value) && (Array.isArray(value) || isArguments(value))) {
				if (shallow) {
					let j = 0;
					const len = value.length;

					while (j < len) output[idx++] = value[j++];
				} else {
					flatten(value, shallow, strict, output);
					idx = output.length;
				}
			} else if (!strict) {
				output[idx++] = value;
			}
		});

		return output;
	};

	var flatten_1 = (array, shallow) => flatten(array, shallow, false);

	var map = (obj, iteratee, context) => {
		iteratee = cb(iteratee, context);
		const keys = !isArrayLike(obj) && getKeys(obj);
		const { length } = keys || obj;
		const results = Array(length);

		for (let index = 0; index < length; index++) {
			const currentKey = keys ? keys[index] : index;

			results[index] = iteratee(obj[currentKey], currentKey, obj);
		}

		return results;
	};

	var lib = {
		shallowProperty,
		getLength,
		isArrayLike,
		isFunction,
		isObject,
		isArguments,
		identity,
		getKeys,
		property,
		matcher,
		isMatch,
		optimizeCb,
		cb,
		forEach,
		map,
		flatten: flatten_1
	};

	const {
		getLength: getLength$1,
		isFunction: isFunction$1,
		isObject: isObject$1,
		identity: identity$1,
		property: property$1,
		matcher: matcher$1,
		optimizeCb: optimizeCb$1,
		cb: cb$1,
		forEach: forEach$1,
		map: map$1,
		flatten: flatten$1
	} = lib;

	const isNumber = obj => toString.call(obj) === '[object Number]';

	const isUndefined = obj => obj === void 0;

	const constant = value => () => value;

	const keyInObj = (value, key, obj) => key in obj;

	const allKeys = obj => {
		if (!isObject$1(obj)) return [];
		const keys = [];

		for (const key in obj) keys.push(key);

		return keys;
	};

	var packageUtils = {
		getLength: getLength$1,
		optimizeCb: optimizeCb$1,
		isFunction: isFunction$1,
		isNumber,
		isUndefined,
		property: property$1,
		matcher: matcher$1,
		identity: identity$1,
		constant,
		keyInObj,
		allKeys,
		cb: cb$1,
		forEach: forEach$1,
		map: map$1,
		flatten: flatten$1
	};

	const {
		keyInObj: keyInObj$1,
		allKeys: allKeys$1,
		optimizeCb: optimizeCb$2,
		isFunction: isFunction$2,
		flatten: flatten$2
	} = packageUtils;

	var pickUtil = (obj, ...keys) => {
		const result = {};
		let [iteratee] = keys;

		if (!obj) {
			return result;
		}

		if (isFunction$2(iteratee)) {
			if (keys.length > 1) iteratee = optimizeCb$2(iteratee, keys[1]);
			keys = allKeys$1(obj);
		} else {
			iteratee = keyInObj$1;
			keys = flatten$2(keys);
			obj = Object(obj);
		}

		keys.forEach(key => {
			const value = obj[key];

			if (iteratee(value, key, obj)) {
				result[key] = value;
			}
		});

		return result;
	};

	return pickUtil;

})));
